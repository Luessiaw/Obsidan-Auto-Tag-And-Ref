/*
THIS IS A GENERATED/BUNDLED FILE BY ESBUILD
if you want to view the source, please visit the github repository of this plugin
*/

var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

var obsidian = require('obsidian');

function getActiveMarkdownFile(app) {
  var activeMarkdownFile = app.workspace.getActiveFile();
  // console.log('activeMarkdownFile:',activeMarkdownFile);
  var activeMarkdownFileName = activeMarkdownFile.path;
  // console.log('activeMarkdownFile.path:',activeMarkdownFile.path);
  const basePath = activeMarkdownFile.vault.adapter.basePath;
  // console.log('activeMarkdownFile.vault.adapter.basePath:',activeMarkdownFile.vault.adapter.basePath);
  // activeMarkdownFile = abstractFileToMarkdownTFile(activeMarkdownFile);
  var path = require('path');
  activeMarkdownFile = path.join(basePath,activeMarkdownFileName);
  // console.log("joined path:",activeMarkdownFile);

  if (!activeMarkdownFile) {
      this.logError("could not get current file.");
      return null;
  }
  activeMarkdownFileName = this.app.vault.getAbstractFileByPath(activeMarkdownFileName);
  return [activeMarkdownFile,activeMarkdownFileName];
}

function ifLog(condition){
  if(condition){
    return console.log
  }
  donothing = function(anyargument){}
  return donothing;
}

function getTokenByCurl(text,pos){//获得{}括起来的内容，或没有{}的一个单独的非空字符。从pos位置开始
  const iflog = false;
  var stack = 0;//用栈标记未配对的左括号{的个数。
  var token = "";
  ifLog(iflog)("getTokenByCurl....")
  while(pos<text.length){
    const char = text.at(pos);
    // console.log([token,char,stack])
    token += char;
    pos += 1;
    if (char!="\\"){
      if (char=="{"){
        stack += 1;
      }else if(char=="}"){
        stack -= 1;
      }else if(" \n\t".includes(char)){
        continue
      }
    }else{
      if(pos<text.length){
        token += text.at(pos);
        pos += 1;
      }
    }
    if (!stack){
      break
    }
  }
  ifLog(iflog)("token=",token," pos=",pos)
  return [token,pos];
}

function getTokenBySquare(text,pos){//获得[]括起来的内容作为可选参数。不需要匹配[]
  const iflog = false;
  ifLog(iflog)("getTokenBySquare...")
  var char;
  var token = "";
  while (pos<text.length){
    char = text.at(pos);
    if (" \t\n".includes(char)){
      token += char
      pos += 1;//跳过空白字符
    }else{
      break
    }
  }
  if (char!="["){
    ifLog(iflog)("no token.");
    // return token//没有可选参数
  }else{
    token += "[";
    pos += 1;
    while(pos<text.length){
      if (text.at(pos)=="]"){
        token += "]";
        break
      }
      var [tokenCurl,pos] = getTokenByCurl(text,pos);
      token += tokenCurl;
    }
    pos += 1;
    ifLog(iflog)("token=",token," pos=",pos);
  }
  return [token,pos]
}

const tagOrLabelRegex = /(\\tag)|(\\Label)/g

function splitTexByTagAndLabel(text){//根据text中\tag和\Label的位置获取列表。需要预先删除text中的定义语句。
  const tagsOrLabels = text.matchAll(tagOrLabelRegex);
  var start = 0;
  const textList = [];
  for (let tagOrLabel of tagsOrLabels){
    const regexTex = tagOrLabel[0];
    var pos = tagOrLabel.index + regexTex.length;
    var optionalArg = "";
    var arg = "";
    if (regexTex=="\\tag"){//假如是\tag命令，只需要捕获一个token
      [arg,pos] = getTokenByCurl(text,pos)
    }else{
      [optionalArg,pos] = getTokenBySquare(text,pos);
      [arg,pos] = getTokenByCurl(text,pos);
    }
    const totalArg = optionalArg + arg;
    // console.log("split,optionalArg=",optionalArg)
    const textSlice = {
      text:text.slice(start,pos),
      regexTex:regexTex + totalArg,
      optionalArg:removeSpaceAndSquareBracket(optionalArg),
      arg:removeSpaceAndCurl(arg),
      argChangedTo:"",
      format:getFormat(arg)
    }
    textList.push(textSlice);
    start = pos;
  }
  const post = text.slice(start);
  return [textList,post]
}

function readFile(activeFile){//读取文件获得文本
  var fs = require("fs");
  const filecontent = fs.readFileSync(activeFile,"utf-8");
  return filecontent
}

function removeSpaceAndCurl(string){//去除字符两端的空白字符和花括号
  // console.log(string);
  string = string.replace(/\s*/g,""); // 删除空白字符
  string = string.replace(/^\{|\}$/g,""); // 去除两端的花括号
  return string;
}

function removeSpaceAndSquareBracket(string){//删除两端的空白字符或方括号
  const iflog = false;
  ifLog(iflog)("string=",string)
  // console.log(string)
  string = string.replace(/\s*/g,""); // 删除空白字符
  string = string.replace(/^\[|\]$/g,""); // 去除两端的花括号
  return string;
}

function getFormat(string){
  string = removeSpaceAndCurl(string);
  if (!string){ // 如果字符串为空,则默认格式为数字
    return ["1"];
  }

  if (/[0-9a-zA-Z]/g.test(string)){//判断是否含有数字或字母
    var format = [];
    string = string.replace(/^[^0-9a-zA-Z]*/,"") // 去除开头的非数字或字母
    while (string){
      // console.log(string);
      var match = string.match(/((?:[0-9]+)|(?:[a-z]|[A-Z]))/);//连续的字母当作多段
      if (/[0-9]+/.test(match[1])){
        format.push("1");// 数字
      }else if(/[a-z]/.test(match[1])){
        format.push("a");
      }else{format.push("A")}

      string = string.slice(match.index+match[1].length);
      if (string){
        match = string.match(/^[^0-9a-zA-Z]*/);
        string = string.slice(match.index+match[0].length);
        format.push(match[0]);
      }
    }
  }
  else{ //不含数字和字母,则格式为第一个字符乘以n次
    var format = string.slice(0,1);
  };
  return format;
}

class Formats{ // 自定义类。我不知道如何自定义 Set 的比较函数。（Set中添加列表无法排除列表相同的情形）
  list;

  constructor(filecontentlist){
    this.list = filecontentlist;
    this.numberLevels = new Map();
    this.numberLevels.set("1",["1"]);
    this.numberLevels.set("A",["A"]);
    this.numberLevels.set("a",["a"]);
    //这个Map形如 {"*":1,"1":["1","1","1"],"A":["a","a","b"]} 
    //key 分为非数字或字母的字符，和数字1或小写a或大写A。
    //前者的value是一个整数，表示该种key已经出现了几次。
    //后者的value是一个列表，表示各级的计数。
    // this.freshFileContentList("");
  }

  typeOfFormatChar(char){
    if (/[0-9]+/.test(char)){
      return "1";
    }else if(/[a-z]/.test(char)){ //字母只有一位
      return "a";
    }else if(/[A-Z]/.test(char)){ //大写字母
      return "A";
    }else{//非数字或字母，重复第一个字符
      return char.substring(0,1);
    }
  }

  isNumberOrLetter(char){//判断是否是数字或字母
    const typeofchar = this.typeOfFormatChar(char);
    return (typeofchar && '1aA'.includes(typeofchar))
  }

  addTagChar(typeofchar){//向this.numberLevels添加key
    if (!this.numberLevels.has(typeofchar)){//肯定不是数字或字母，所以不设层级
      this.numberLevels.set(typeofchar,0)
    }
  }

  nextNumber(number,level){//需要递进的一定是数字或字母
    const typeofchar = this.typeOfFormatChar(number);
    const levels = this.numberLevels.get(typeofchar,["1"]);
    if (level>=levels.length){//如果levels的长度不足，则用typeofchar补全。
      levels.concat(Array(level+1-levels.length).fill(typeofchar));
    }
    number = levels[level];
    var nextfunc;
    if (typeofchar=="1"){
      nextfunc = function(){return String(Number(number)+1)};
    }else if (typeofchar=="a"){
      nextfunc = function(){return String.fromCharCode(Math.min(number.charCodeAt()+1,122))};
    }else{
      nextfunc = function(){return String.fromCharCode(Math.min(number.charCodeAt()+1,90))};
    }

    const nextnumber = nextfunc();
    levels[level] = nextnumber;
    return nextnumber;
  }

  copyNumberOrLetter(number,level){
    const typeofchar = this.typeOfFormatChar(number);
    return this.numberLevels.get(typeofchar)[level];
  }

  restartNumberOrLetter(number,level){//重新计数。
    // console.log('restart numbering...')
    const typeofchar = this.typeOfFormatChar(number);
    // console.log("type of char is ",typeofchar);
    this.numberLevels.get(typeofchar)[level] = typeofchar;
    return typeofchar;
  }

  levelOfFomat(format){//判断一个列表共包含几个数字/字母
    var levels = 0;
    for (char of format){
      if (this.isNumberOrLetter(char)){
        levels++;
      }
    }
    return levels
  }

  indexOfNumberOrLetter(tag){//一个列表形的tag,返回数字或字母的索引值
    // console.log("tag is",tag);
    const index = [];
    for (let i in tag){
      if (this.isNumberOrLetter(tag[i])){
        // console.log('i',i);
        index.push(i);
      }
    }
    // console.log("index of numbers or letters is",index);
    return index
  }

  lastSameLevelOfTags(tag1,tag2){//两个列表形的tag,比较最后一个相同的层级。不比较分隔符。
    const index1 = this.indexOfNumberOrLetter(tag1);
    const index2 = this.indexOfNumberOrLetter(tag2);
    // console.log(index1,index2);
    const max = Math.min(index1.length,index2.length);
    var level = -1;
    for (let i=0;i<max;i++){
      const typeofchar1 = this.typeOfFormatChar(tag1[index1[i]]);
      const typeofchar2 = this.typeOfFormatChar(tag2[index2[i]]);
      if (typeofchar1==typeofchar2){
        level++;
      }
    }
    // console.log("last same level of ",tag1," and ",tag2," is ",level);
    return level;
  }

  nextTag(tag,formerTags){//需要比较上一个tag来决定增加的层级。这里的tag已经转化为type了
    const showlog = false;
    if (typeof tag=="string"){//如果是非数字或字母的符号，不需要看层级，直接乘以倍数
      ifLog(showlog)("Type of ",tag," is String.");
      this.addTagChar(tag);//添加tag
      const number = this.numberLevels.get(tag)+1;
      this.numberLevels.set(tag,number)
      const next = tag.repeat(number)
      ifLog(showlog)("nextTag=",next)
      return next;
    }else{
      ifLog(showlog)("Type of ",tag," is List.");
      //tag是列表
      const formerTag = formerTags.at(-1);
      ifLog(showlog)("tag=",tag," formerTag=",formerTag);
      // if (formerTag && formerTag.constructor!=Array){//如果formerTag是非数字或字母的符号，则将其转换为null
      //   ifLog(showlog)(formerTag,"is not array, changed to null.")
      //   formerTag = null;
      // }
      const level = this.lastSameLevelOfTags(tag,formerTag);
      ifLog(showlog)("last same level of ",tag," and ",formerTag," is ",level);
      const index = this.indexOfNumberOrLetter(tag);
      ifLog(showlog)("index of ",tag," is ",index);
      for (let j in index){//j表示层级，i表示在tag中的索引
        const i = index[j]
        // ifLog(showlog)("i=",i," j=",j);
        if (j<level){
          ifLog(showlog)("j=",j,"<level=",level);
          tag[i] = this.copyNumberOrLetter(tag[i],j);
          ifLog(showlog)("tag["+i+"] copied as",tag[i]);
        }else if(j==level){
          ifLog(showlog)("j=",j,"==level=",level);
          tag[i] = this.nextNumber(tag[i],j)
          ifLog(showlog)("tag["+i+"] nexted as",tag[i]);
        }else{
          ifLog(showlog)("j=",j,">level=",level);
          tag[i] = this.restartNumberOrLetter(tag[i],j)
          ifLog(showlog)("tag["+i+"] restarded as",tag[i]);
        }
      }
      formerTags.push(tag);
    }
    ifLog(showlog)('tag is changed to',tag);
    return tag;

    // if (this.#compareTags(tag,formerTag)){//两个tag同类，则只增加tag的最后一级
    //   var i = 0;
    //   for (char of tag.reverse()){
    //     if (this.isNumberOrLetter(char)){//找到最后一级。
    //       break
    //     }
    //     i++;//i标记的是char的位置
    //   }
    //   levels = this.levelOfFomat(tag);
    //   const nextChar = this.nextNumber(this.numberLevels.get(char)[levels]);
    //   this.numberLevels.get(char)[levels] = nextChar;
    //   tag[i] = nextChar;
    //   return tag;
    // }else{//如果两个tag不同类
      
    // }
  }

  tag2Text(tag){//list转化为String
    if (typeof tag=="string"){
      return tag
    }
    return tag.join("")
  }

  freshFileContentList(){
    // console.log("Freshing...")
    const formerTag = [null];
    var freshedfilecontent = "";
    for (let list of this.list){
      // console.log("list:",list)
      var tag = list.format;
      // console.log("tag:",tag);
      tag = this.nextTag(tag,formerTag);
      list.argChangedTo = this.tag2Text(tag);
      // formerTag = tag;
      // console.log(list.optionalArg);
      const regexTextChangedTo = "\\Label["+list.optionalArg+"]{"+list.argChangedTo+"}"
      list.text = list.text.replace(list.regexTex,regexTextChangedTo)
      // console.log("list changed to",list);
      freshedfilecontent += list.text;
    }
    // console.log("formats changed to",this);
    // console.log("Fresed filecontent=",freshedfilecontent);
    return freshedfilecontent;
  }

}

function setRefRule(filecontentlist){//用于更新reference
  const labelMap = new Map();
  const numberMap = new Map();
  for (let list of filecontentlist){
    const arg = list.arg;
    const optionalArg = list.optionalArg;
    const argChangedTo = list.argChangedTo;
    if (arg){
      numberMap.set(arg,argChangedTo)
    }
    if (optionalArg){//\Label[]里的标签也映射为
      labelMap.set(optionalArg,argChangedTo)
    }
  }
  return [labelMap,numberMap];
}

const defLabelText = "$\\newcommand\\Label[2][]{\\tag{#2}}$\n";
const defRefText = "$\\newcommand\\Ref[2][]{(\\mbox{#2})}$\n";

function addRefAndLabelDef(text){//添加\Ref和\Label命令
  for(let defText of [defLabelText,defRefText]){
    if (!text.includes(defText)){
      text = defText + text;
    }  
  }
  return text;
}

function removeRefOrLabelText(text){//删除\Ref和\Label的定义语句
  for(let defText of [defLabelText,defRefText]){
    text = text.replace(defText,"")
  }
  return text;
}

const refRegex = /\\Ref/g

function reRefText(text,labelMap,numberMap){
  const iflog = false;
  ifLog(iflog)("labelMap=",labelMap," numberMap=",numberMap);
  const refs = text.matchAll(refRegex);
  var start = 0;
  const textList = [];
  for (let ref of refs){
    const regexTex = ref[0];
    var pos = ref.index + regexTex.length;
    var optionalArg = "";
    var arg = "";
    var [optionalArg,pos] = getTokenBySquare(text,pos);
    var [arg,pos] = getTokenByCurl(text,pos);
    ifLog(iflog)("reRefText,optionalArg=",optionalArg," arg=",arg);
    const totalRegex = regexTex+optionalArg + arg;//要在去括号和空白前确定totalRegex
    ifLog(iflog)("TotalRegex=",totalRegex);
    optionalArg = removeSpaceAndSquareBracket(optionalArg);
    arg = removeSpaceAndCurl(arg);
    ifLog(iflog)("bracket removed. Optional=",optionalArg," arg=",arg)
    var textSlice = text.slice(start,pos);
    var refChangedTo = "";
    if(optionalArg&&labelMap.has(optionalArg)){//如果设置了标签，就以标签的引用为准
      ifLog(iflog)("use label to change tag")
      refChangedTo = "\\Ref["+optionalArg+"]{"+labelMap.get(optionalArg)+"}"
    }else if (arg&&numberMap.has(arg)){
      ifLog(iflog)("use number to change tag")
      refChangedTo = "\\Ref["+optionalArg+"]{"+numberMap.get(arg)+"}"
    }else{
      ifLog(iflog)("tag not changed.")
      refChangedTo = totalRegex;
    }
    // ifLog(iflog)("totalRex in textSlice:",textSlice.includes(totalRegex))
    ifLog(iflog)(totalRegex,"=>",refChangedTo)
    textSlice = textSlice.replace(totalRegex,refChangedTo)
    textList.push(textSlice);
    start = pos;
  }
  ifLog(iflog)("textList=",textList)
  // const post = ;
  var finalText = textList.join("")+text.slice(start);
  return finalText
}

// async function renumbering(filecontentlist) { //分割完毕后重新编号
//   var setOfFormats = new SetOfFormats();
//   let list = await filecontentlist
//   for (singleText of list){
//     // console.log(singleText.format);
//     setOfFormats.add(singleText.format);
//   }
//   // console.log(setOfFormats);

// }


// main.ts
var main_exports = {};
__export(main_exports, {
  default: () => AutoTagAndRefPlugin
});
module.exports = __toCommonJS(main_exports);
var import_obsidian = require("obsidian");
var DEFAULT_SETTINGS = {
  mySetting: "default"
};
var AutoTagAndRefPlugin = class extends import_obsidian.Plugin {
  async onload() {
    console.log("loading plugin");
    await this.loadSettings();
    // const ribbonIconEl = this.addRibbonIcon("dice", "Sample Plugin", (evt) => {
    //   new Notice("HELLO!");
    // });
    // ribbonIconEl.addClass("my-plugin-ribbon-class");
    this.addCommand({
      id: "refresh-tags&refs",
      name: "Refresh Tags and References",
      callback: () => {
        try{
          // console.log("Formula Auot Refreshing...");
          var [activeFile,activeFileName] = getActiveMarkdownFile(this.app);
          // console.log("activeFile:",activeFile);
          var filecontent = readFile(activeFile);
          filecontent = removeRefOrLabelText(filecontent);
          var [filecontentlist,postcontent] = splitTexByTagAndLabel(filecontent);
          // console.log("filecontentlist:",filecontentlist);
          const formats = new Formats(filecontentlist);
          // console.log(formats)
          var freshedFileContent = formats.freshFileContentList();

          freshedFileContent += postcontent;

          const [labelMap,numberMap] = setRefRule(formats.list);
          // console.log("refRuleMap",refRuleMap)

          freshedFileContent = reRefText(freshedFileContent,labelMap,numberMap)

          freshedFileContent = addRefAndLabelDef(freshedFileContent);
          // console.log("file content after add ref:",freshedFileContent);

          // console.log("activeFille",activeFile);
          // console.log("fresed file content:",freshedFileContentList);
          this.app.vault.modify(activeFileName,freshedFileContent)
          new Notice("Auto-Tag & Ref: Done.")
        }catch(err){
          const message = "AutoTagAndRef Error:\n"+err.message;
          new Notice(message)
        }
      }
    });

    // this.addSettingTab(new SampleSettingTab(this.app, this));
    // this.registerDomEvent(document, "click", (evt) => {
    //   console.log("click", evt);
    // });
    // this.registerInterval(window.setInterval(() => console.log("setInterval"), 5 * 60 * 1e3));
  }
  onunload() {
    console.log("unloading plugin");
  }
  async loadSettings() {
    this.settings = Object.assign({}, DEFAULT_SETTINGS, await this.loadData());
  }
  async saveSettings() {
    await this.saveData(this.settings);
  }
};
var SampleModal = class extends import_obsidian.Modal {
  constructor(app) {
    super(app);
  }
  onOpen() {
    const { contentEl } = this;
    contentEl.setText("Woah!");
  }
  onClose() {
    const { contentEl } = this;
    contentEl.empty();
  }
};
var SampleSettingTab = class extends import_obsidian.PluginSettingTab {
  constructor(app, plugin) {
    super(app, plugin);
    this.plugin = plugin;
  }
  display() {
    const { containerEl } = this;
    containerEl.empty();
    containerEl.createEl("h2", { text: "Settings for my awesome plugin." });
    new import_obsidian.Setting(containerEl).setName("Setting #1").setDesc("It's a secret").addText((text) => text.setPlaceholder("Enter your secret").setValue(this.plugin.settings.mySetting).onChange(async (value) => {
      console.log("Secret: " + value);
      this.plugin.settings.mySetting = value;
      await this.plugin.saveSettings();
    }));
  }
};

//# sourceMappingURL=data:application/json;base64,ewogICJ2ZXJzaW9uIjogMywKICAic291cmNlcyI6IFsibWFpbi50cyJdLAogICJzb3VyY2VzQ29udGVudCI6IFsiaW1wb3J0IHsgQXBwLCBFZGl0b3IsIE1hcmtkb3duVmlldywgTW9kYWwsIE5vdGljZSwgUGx1Z2luLCBQbHVnaW5TZXR0aW5nVGFiLCBTZXR0aW5nIH0gZnJvbSAnb2JzaWRpYW4nO1xyXG5cclxuLy8gUmVtZW1iZXIgdG8gcmVuYW1lIHRoZXNlIGNsYXNzZXMgYW5kIGludGVyZmFjZXMhXHJcblxyXG5pbnRlcmZhY2UgTXlQbHVnaW5TZXR0aW5ncyB7XHJcblx0bXlTZXR0aW5nOiBzdHJpbmc7XHJcbn1cclxuXHJcbmNvbnN0IERFRkFVTFRfU0VUVElOR1M6IE15UGx1Z2luU2V0dGluZ3MgPSB7XHJcblx0bXlTZXR0aW5nOiAnZGVmYXVsdCdcclxufVxyXG5cclxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgTXlQbHVnaW4gZXh0ZW5kcyBQbHVnaW4ge1xyXG5cdHNldHRpbmdzOiBNeVBsdWdpblNldHRpbmdzO1xyXG5cclxuXHRhc3luYyBvbmxvYWQoKSB7XHJcblx0XHRjb25zb2xlLmxvZygnbG9hZGluZyBwbHVnaW4nKTtcclxuXHRcdGF3YWl0IHRoaXMubG9hZFNldHRpbmdzKCk7XHJcblxyXG5cdFx0Ly8gVGhpcyBjcmVhdGVzIGFuIGljb24gaW4gdGhlIGxlZnQgcmliYm9uLlxyXG5cdFx0Y29uc3QgcmliYm9uSWNvbkVsID0gdGhpcy5hZGRSaWJib25JY29uKCdkaWNlJywgJ1NhbXBsZSBQbHVnaW4nLCAoZXZ0OiBNb3VzZUV2ZW50KSA9PiB7XHJcblx0XHRcdC8vIENhbGxlZCB3aGVuIHRoZSB1c2VyIGNsaWNrcyB0aGUgaWNvbi5cclxuXHRcdFx0bmV3IE5vdGljZSgnVGhpcyBpcyBhIG5vdGljZSEnKTtcclxuXHRcdFx0Y29uc3QgeyB3b3Jrc3BhY2UgfSA9IHRoaXMuYXBwO1xyXG5cdFx0XHRjb25zdCBhY3RpdmVWaWV3ID0gd29ya3NwYWNlLmdldEFjdGl2ZVZpZXdPZlR5cGUoTWFya2Rvd25WaWV3KTtcclxuXHJcblx0XHRcdGlmIChhY3RpdmVWaWV3KSB7ICAvLyBUaGUgYWN0aXZlIHZpZXcgbWlnaHQgbm90IGJlIGEgbWFya2Rvd24gdmlld1xyXG5cdFx0XHQvLyBSZWFkIHRoZSBmaWxlIChmcm9tIGVpdGhlciB0aGUgY2FjaGUgb3IgZnJvbSBkaXNrKVxyXG5cdFx0XHQvLyBOb3RlOiBgY2FjaGVkUmVhZGAgcmV0dXJucyBzdGFsZSBkYXRhIHdoaWNoIHNob3VsZCBiZSBnb29kIGZvciBtb3N0IGNhc2VzLiBcclxuXHRcdFx0Ly8gSG93ZXZlciwgaWYgeW91IHBsYW4gb24gd3JpdGluZyBiYWNrIHRvIGRpc2ssIHVzZSBgdmF1bHQucmVhZGAgaGVyZSBcclxuXHRcdFx0Ly8gaW5zdGVhZCB0byBhdm9pZCBkYXRhIGxvc3MuXHJcblx0XHRcdC8vIGNvbnN0IGZpbGVDb250ZW50cyA9IHRoaXMuY2FjaGVkUmVhZChhY3RpdmVWaWV3LmZpbGUpO1xyXG5cdFx0XHR9XHJcblx0XHR9KTtcclxuXHRcdC8vIFBlcmZvcm0gYWRkaXRpb25hbCB0aGluZ3Mgd2l0aCB0aGUgcmliYm9uXHJcblx0XHRyaWJib25JY29uRWwuYWRkQ2xhc3MoJ215LXBsdWdpbi1yaWJib24tY2xhc3MnKTtcclxuXHJcblx0XHQvLyBUaGlzIGFkZHMgYSBzdGF0dXMgYmFyIGl0ZW0gdG8gdGhlIGJvdHRvbSBvZiB0aGUgYXBwLiBEb2VzIG5vdCB3b3JrIG9uIG1vYmlsZSBhcHBzLlxyXG5cdFx0Ly8gY29uc3Qgc3RhdHVzQmFySXRlbUVsID0gdGhpcy5hZGRTdGF0dXNCYXJJdGVtKCk7XHJcblx0XHQvLyBzdGF0dXNCYXJJdGVtRWwuc2V0VGV4dCgnU3RhdHVzIEJhciBUZXh0Jyk7XHJcblxyXG5cdFx0Ly8gVGhpcyBhZGRzIGEgc2ltcGxlIGNvbW1hbmQgdGhhdCBjYW4gYmUgdHJpZ2dlcmVkIGFueXdoZXJlXHJcblx0XHR0aGlzLmFkZENvbW1hbmQoe1xyXG5cdFx0XHRpZDogJ29wZW4tc2FtcGxlLW1vZGFsLXNpbXBsZScsXHJcblx0XHRcdG5hbWU6ICdPcGVuIHNhbXBsZSBtb2RhbCAoc2ltcGxlKScsXHJcblx0XHRcdGNhbGxiYWNrOiAoKSA9PiB7XHJcblx0XHRcdFx0bmV3IFNhbXBsZU1vZGFsKHRoaXMuYXBwKS5vcGVuKCk7XHJcblx0XHRcdH1cclxuXHRcdH0pO1xyXG5cdFx0Ly8gVGhpcyBhZGRzIGFuIGVkaXRvciBjb21tYW5kIHRoYXQgY2FuIHBlcmZvcm0gc29tZSBvcGVyYXRpb24gb24gdGhlIGN1cnJlbnQgZWRpdG9yIGluc3RhbmNlXHJcblx0XHR0aGlzLmFkZENvbW1hbmQoe1xyXG5cdFx0XHRpZDogJ3NhbXBsZS1lZGl0b3ItY29tbWFuZCcsXHJcblx0XHRcdG5hbWU6ICdTYW1wbGUgZWRpdG9yIGNvbW1hbmQnLFxyXG5cdFx0XHRlZGl0b3JDYWxsYmFjazogKGVkaXRvcjogRWRpdG9yLCB2aWV3OiBNYXJrZG93blZpZXcpID0+IHtcclxuXHRcdFx0XHRjb25zb2xlLmxvZyhlZGl0b3IuZ2V0U2VsZWN0aW9uKCkpO1xyXG5cdFx0XHRcdGVkaXRvci5yZXBsYWNlU2VsZWN0aW9uKCdTYW1wbGUgRWRpdG9yIENvbW1hbmQnKTtcclxuXHRcdFx0fVxyXG5cdFx0fSk7XHJcblx0XHQvLyBUaGlzIGFkZHMgYSBjb21wbGV4IGNvbW1hbmQgdGhhdCBjYW4gY2hlY2sgd2hldGhlciB0aGUgY3VycmVudCBzdGF0ZSBvZiB0aGUgYXBwIGFsbG93cyBleGVjdXRpb24gb2YgdGhlIGNvbW1hbmRcclxuXHRcdHRoaXMuYWRkQ29tbWFuZCh7XHJcblx0XHRcdGlkOiAnb3Blbi1zYW1wbGUtbW9kYWwtY29tcGxleCcsXHJcblx0XHRcdG5hbWU6ICdPcGVuIHNhbXBsZSBtb2RhbCAoY29tcGxleCknLFxyXG5cdFx0XHRjaGVja0NhbGxiYWNrOiAoY2hlY2tpbmc6IGJvb2xlYW4pID0+IHtcclxuXHRcdFx0XHQvLyBDb25kaXRpb25zIHRvIGNoZWNrXHJcblx0XHRcdFx0Y29uc3QgbWFya2Rvd25WaWV3ID0gdGhpcy5hcHAud29ya3NwYWNlLmdldEFjdGl2ZVZpZXdPZlR5cGUoTWFya2Rvd25WaWV3KTtcclxuXHRcdFx0XHRpZiAobWFya2Rvd25WaWV3KSB7XHJcblx0XHRcdFx0XHQvLyBJZiBjaGVja2luZyBpcyB0cnVlLCB3ZSdyZSBzaW1wbHkgXCJjaGVja2luZ1wiIGlmIHRoZSBjb21tYW5kIGNhbiBiZSBydW4uXHJcblx0XHRcdFx0XHQvLyBJZiBjaGVja2luZyBpcyBmYWxzZSwgdGhlbiB3ZSB3YW50IHRvIGFjdHVhbGx5IHBlcmZvcm0gdGhlIG9wZXJhdGlvbi5cclxuXHRcdFx0XHRcdGlmICghY2hlY2tpbmcpIHtcclxuXHRcdFx0XHRcdFx0bmV3IFNhbXBsZU1vZGFsKHRoaXMuYXBwKS5vcGVuKCk7XHJcblx0XHRcdFx0XHR9XHJcblxyXG5cdFx0XHRcdFx0Ly8gVGhpcyBjb21tYW5kIHdpbGwgb25seSBzaG93IHVwIGluIENvbW1hbmQgUGFsZXR0ZSB3aGVuIHRoZSBjaGVjayBmdW5jdGlvbiByZXR1cm5zIHRydWVcclxuXHRcdFx0XHRcdHJldHVybiB0cnVlO1xyXG5cdFx0XHRcdH1cclxuXHRcdFx0fVxyXG5cdFx0fSk7XHJcblxyXG5cdFx0Ly8gVGhpcyBhZGRzIGEgc2V0dGluZ3MgdGFiIHNvIHRoZSB1c2VyIGNhbiBjb25maWd1cmUgdmFyaW91cyBhc3BlY3RzIG9mIHRoZSBwbHVnaW5cclxuXHRcdHRoaXMuYWRkU2V0dGluZ1RhYihuZXcgU2FtcGxlU2V0dGluZ1RhYih0aGlzLmFwcCwgdGhpcykpO1xyXG5cclxuXHRcdC8vIElmIHRoZSBwbHVnaW4gaG9va3MgdXAgYW55IGdsb2JhbCBET00gZXZlbnRzIChvbiBwYXJ0cyBvZiB0aGUgYXBwIHRoYXQgZG9lc24ndCBiZWxvbmcgdG8gdGhpcyBwbHVnaW4pXHJcblx0XHQvLyBVc2luZyB0aGlzIGZ1bmN0aW9uIHdpbGwgYXV0b21hdGljYWxseSByZW1vdmUgdGhlIGV2ZW50IGxpc3RlbmVyIHdoZW4gdGhpcyBwbHVnaW4gaXMgZGlzYWJsZWQuXHJcblx0XHR0aGlzLnJlZ2lzdGVyRG9tRXZlbnQoZG9jdW1lbnQsICdjbGljaycsIChldnQ6IE1vdXNlRXZlbnQpID0+IHtcclxuXHRcdFx0Y29uc29sZS5sb2coJ2NsaWNrJywgZXZ0KTtcclxuXHRcdH0pO1xyXG5cclxuXHRcdC8vIFdoZW4gcmVnaXN0ZXJpbmcgaW50ZXJ2YWxzLCB0aGlzIGZ1bmN0aW9uIHdpbGwgYXV0b21hdGljYWxseSBjbGVhciB0aGUgaW50ZXJ2YWwgd2hlbiB0aGUgcGx1Z2luIGlzIGRpc2FibGVkLlxyXG5cdFx0dGhpcy5yZWdpc3RlckludGVydmFsKHdpbmRvdy5zZXRJbnRlcnZhbCgoKSA9PiBjb25zb2xlLmxvZygnc2V0SW50ZXJ2YWwnKSwgNSAqIDYwICogMTAwMCkpO1xyXG5cdH1cclxuXHJcblx0b251bmxvYWQoKSB7XHJcblx0XHRjb25zb2xlLmxvZygndW5sb2FkaW5nIHBsdWdpbicpXHJcblx0fVxyXG5cclxuXHRhc3luYyBsb2FkU2V0dGluZ3MoKSB7XHJcblx0XHR0aGlzLnNldHRpbmdzID0gT2JqZWN0LmFzc2lnbih7fSwgREVGQVVMVF9TRVRUSU5HUywgYXdhaXQgdGhpcy5sb2FkRGF0YSgpKTtcclxuXHR9XHJcblxyXG5cdGFzeW5jIHNhdmVTZXR0aW5ncygpIHtcclxuXHRcdGF3YWl0IHRoaXMuc2F2ZURhdGEodGhpcy5zZXR0aW5ncyk7XHJcblx0fVxyXG59XHJcblxyXG5jbGFzcyBTYW1wbGVNb2RhbCBleHRlbmRzIE1vZGFsIHtcclxuXHRjb25zdHJ1Y3RvcihhcHA6IEFwcCkge1xyXG5cdFx0c3VwZXIoYXBwKTtcclxuXHR9XHJcblxyXG5cdG9uT3BlbigpIHtcclxuXHRcdGNvbnN0IHtjb250ZW50RWx9ID0gdGhpcztcclxuXHRcdGNvbnRlbnRFbC5zZXRUZXh0KCdXb2FoIScpO1xyXG5cdH1cclxuXHJcblx0b25DbG9zZSgpIHtcclxuXHRcdGNvbnN0IHtjb250ZW50RWx9ID0gdGhpcztcclxuXHRcdGNvbnRlbnRFbC5lbXB0eSgpO1xyXG5cdH1cclxufVxyXG5cclxuY2xhc3MgU2FtcGxlU2V0dGluZ1RhYiBleHRlbmRzIFBsdWdpblNldHRpbmdUYWIge1xyXG5cdHBsdWdpbjogTXlQbHVnaW47XHJcblxyXG5cdGNvbnN0cnVjdG9yKGFwcDogQXBwLCBwbHVnaW46IE15UGx1Z2luKSB7XHJcblx0XHRzdXBlcihhcHAsIHBsdWdpbik7XHJcblx0XHR0aGlzLnBsdWdpbiA9IHBsdWdpbjtcclxuXHR9XHJcblxyXG5cdGRpc3BsYXkoKTogdm9pZCB7XHJcblx0XHRjb25zdCB7Y29udGFpbmVyRWx9ID0gdGhpcztcclxuXHJcblx0XHRjb250YWluZXJFbC5lbXB0eSgpO1xyXG5cclxuXHRcdGNvbnRhaW5lckVsLmNyZWF0ZUVsKCdoMicsIHt0ZXh0OiAnU2V0dGluZ3MgZm9yIG15IGF3ZXNvbWUgcGx1Z2luLid9KTtcclxuXHJcblx0XHRuZXcgU2V0dGluZyhjb250YWluZXJFbClcclxuXHRcdFx0LnNldE5hbWUoJ1NldHRpbmcgIzEnKVxyXG5cdFx0XHQuc2V0RGVzYygnSXRcXCdzIGEgc2VjcmV0JylcclxuXHRcdFx0LmFkZFRleHQodGV4dCA9PiB0ZXh0XHJcblx0XHRcdFx0LnNldFBsYWNlaG9sZGVyKCdFbnRlciB5b3VyIHNlY3JldCcpXHJcblx0XHRcdFx0LnNldFZhbHVlKHRoaXMucGx1Z2luLnNldHRpbmdzLm15U2V0dGluZylcclxuXHRcdFx0XHQub25DaGFuZ2UoYXN5bmMgKHZhbHVlKSA9PiB7XHJcblx0XHRcdFx0XHRjb25zb2xlLmxvZygnU2VjcmV0OiAnICsgdmFsdWUpO1xyXG5cdFx0XHRcdFx0dGhpcy5wbHVnaW4uc2V0dGluZ3MubXlTZXR0aW5nID0gdmFsdWU7XHJcblx0XHRcdFx0XHRhd2FpdCB0aGlzLnBsdWdpbi5zYXZlU2V0dGluZ3MoKTtcclxuXHRcdFx0XHR9KSk7XHJcblx0fVxyXG59XHJcbiJdLAogICJtYXBwaW5ncyI6ICI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQSxzQkFBNEY7QUFRNUYsSUFBTSxtQkFBcUM7QUFBQSxFQUMxQyxXQUFXO0FBQ1o7QUFFQSxJQUFxQixXQUFyQixjQUFzQyx1QkFBTztBQUFBLEVBRzVDLE1BQU0sU0FBUztBQUNkLFlBQVEsSUFBSSxnQkFBZ0I7QUFDNUIsVUFBTSxLQUFLLGFBQWE7QUFHeEIsVUFBTSxlQUFlLEtBQUssY0FBYyxRQUFRLGlCQUFpQixDQUFDLFFBQW9CO0FBRXJGLFVBQUksdUJBQU8sbUJBQW1CO0FBQzlCLFlBQU0sRUFBRSxjQUFjLEtBQUs7QUFDM0IsWUFBTSxhQUFhLFVBQVUsb0JBQW9CLDRCQUFZO0FBRTdELFVBQUksWUFBWTtBQUFBLE1BTWhCO0FBQUEsSUFDRCxDQUFDO0FBRUQsaUJBQWEsU0FBUyx3QkFBd0I7QUFPOUMsU0FBSyxXQUFXO0FBQUEsTUFDZixJQUFJO0FBQUEsTUFDSixNQUFNO0FBQUEsTUFDTixVQUFVLE1BQU07QUFDZixZQUFJLFlBQVksS0FBSyxHQUFHLEVBQUUsS0FBSztBQUFBLE1BQ2hDO0FBQUEsSUFDRCxDQUFDO0FBRUQsU0FBSyxXQUFXO0FBQUEsTUFDZixJQUFJO0FBQUEsTUFDSixNQUFNO0FBQUEsTUFDTixnQkFBZ0IsQ0FBQyxRQUFnQixTQUF1QjtBQUN2RCxnQkFBUSxJQUFJLE9BQU8sYUFBYSxDQUFDO0FBQ2pDLGVBQU8saUJBQWlCLHVCQUF1QjtBQUFBLE1BQ2hEO0FBQUEsSUFDRCxDQUFDO0FBRUQsU0FBSyxXQUFXO0FBQUEsTUFDZixJQUFJO0FBQUEsTUFDSixNQUFNO0FBQUEsTUFDTixlQUFlLENBQUMsYUFBc0I7QUFFckMsY0FBTSxlQUFlLEtBQUssSUFBSSxVQUFVLG9CQUFvQiw0QkFBWTtBQUN4RSxZQUFJLGNBQWM7QUFHakIsY0FBSSxDQUFDLFVBQVU7QUFDZCxnQkFBSSxZQUFZLEtBQUssR0FBRyxFQUFFLEtBQUs7QUFBQSxVQUNoQztBQUdBLGlCQUFPO0FBQUEsUUFDUjtBQUFBLE1BQ0Q7QUFBQSxJQUNELENBQUM7QUFHRCxTQUFLLGNBQWMsSUFBSSxpQkFBaUIsS0FBSyxLQUFLLElBQUksQ0FBQztBQUl2RCxTQUFLLGlCQUFpQixVQUFVLFNBQVMsQ0FBQyxRQUFvQjtBQUM3RCxjQUFRLElBQUksU0FBUyxHQUFHO0FBQUEsSUFDekIsQ0FBQztBQUdELFNBQUssaUJBQWlCLE9BQU8sWUFBWSxNQUFNLFFBQVEsSUFBSSxhQUFhLEdBQUcsSUFBSSxLQUFLLEdBQUksQ0FBQztBQUFBLEVBQzFGO0FBQUEsRUFFQSxXQUFXO0FBQ1YsWUFBUSxJQUFJLGtCQUFrQjtBQUFBLEVBQy9CO0FBQUEsRUFFQSxNQUFNLGVBQWU7QUFDcEIsU0FBSyxXQUFXLE9BQU8sT0FBTyxDQUFDLEdBQUcsa0JBQWtCLE1BQU0sS0FBSyxTQUFTLENBQUM7QUFBQSxFQUMxRTtBQUFBLEVBRUEsTUFBTSxlQUFlO0FBQ3BCLFVBQU0sS0FBSyxTQUFTLEtBQUssUUFBUTtBQUFBLEVBQ2xDO0FBQ0Q7QUFFQSxJQUFNLGNBQU4sY0FBMEIsc0JBQU07QUFBQSxFQUMvQixZQUFZLEtBQVU7QUFDckIsVUFBTSxHQUFHO0FBQUEsRUFDVjtBQUFBLEVBRUEsU0FBUztBQUNSLFVBQU0sRUFBQyxjQUFhO0FBQ3BCLGNBQVUsUUFBUSxPQUFPO0FBQUEsRUFDMUI7QUFBQSxFQUVBLFVBQVU7QUFDVCxVQUFNLEVBQUMsY0FBYTtBQUNwQixjQUFVLE1BQU07QUFBQSxFQUNqQjtBQUNEO0FBRUEsSUFBTSxtQkFBTixjQUErQixpQ0FBaUI7QUFBQSxFQUcvQyxZQUFZLEtBQVUsUUFBa0I7QUFDdkMsVUFBTSxLQUFLLE1BQU07QUFDakIsU0FBSyxTQUFTO0FBQUEsRUFDZjtBQUFBLEVBRUEsVUFBZ0I7QUFDZixVQUFNLEVBQUMsZ0JBQWU7QUFFdEIsZ0JBQVksTUFBTTtBQUVsQixnQkFBWSxTQUFTLE1BQU0sRUFBQyxNQUFNLGtDQUFpQyxDQUFDO0FBRXBFLFFBQUksd0JBQVEsV0FBVyxFQUNyQixRQUFRLFlBQVksRUFDcEIsUUFBUSxlQUFnQixFQUN4QixRQUFRLFVBQVEsS0FDZixlQUFlLG1CQUFtQixFQUNsQyxTQUFTLEtBQUssT0FBTyxTQUFTLFNBQVMsRUFDdkMsU0FBUyxPQUFPLFVBQVU7QUFDMUIsY0FBUSxJQUFJLGFBQWEsS0FBSztBQUM5QixXQUFLLE9BQU8sU0FBUyxZQUFZO0FBQ2pDLFlBQU0sS0FBSyxPQUFPLGFBQWE7QUFBQSxJQUNoQyxDQUFDLENBQUM7QUFBQSxFQUNMO0FBQ0Q7IiwKICAibmFtZXMiOiBbXQp9Cg==
